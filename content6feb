console.log('Content script loaded');
console.log('Current URL:', window.location.href);

const EXCHANGE_RATES = {
    EUR_TO_DKK: 7.45,
    EUR_TO_GBP: 0.86,
    EUR_TO_USD: 1.08
};


let productInfo = {
    gtin: [],
    mpn: [],
    shop: {
        name: '',
        url: window.location.href,
        domain: window.location.hostname
    },
    price: {
        amount: null,
        currency: null,
        rawText: '',
        source: ''
    },
    referrer: {
        url: window.location.href,
        price: null,
        timestamp: new Date().toISOString()
    },
    detectedOn: window.location.hostname,
    foundTimestamp: new Date().toISOString()
};

function getCurrencyCodeFromSymbol(symbol) {
    switch (symbol) {
      case '‚Ç¨': return 'EUR';
      case '¬£': return 'GBP';
      case '$': return 'USD';
      // ...
      default:  return null; // or 'DKK' or your fallback
    }
  }
  function detectCurrency(priceText) {
    if (!priceText) return null;
    const text = priceText.trim();
    if (text.includes('‚Ç¨')) return 'EUR';
    if (text.includes('kr') || text.includes('DKK')) return 'DKK';
    if (text.includes('¬£')) return 'GBP';
    if (text.includes('$')) return 'USD';
    return 'EUR'; // Default to EUR if no currency symbol found
}

let gtinFound = false;
let priceFound = false;
let productData = {
    gtin: null,
    price: null,
    mpn: null
};
let processedGTINs = new Map();
let observer = null;
let currentUrl = window.location.href;
const EUR_TO_DKK_RATE = 7.45;
const EUR_TO_GBP_RATE = 0.86;
const EUR_TO_USD_RATE = 1.08;

function normalizePrice(priceText) {
    if (!priceText) return null;

    try {
        // Clean up the price text
        let price = priceText.trim();
        
        // Remove "from" or "fra" prefix (case insensitive)
        price = price.replace(/^(from|fra)\s+/i, '');
        
        // Remove currency symbols and extra spaces
        price = price.replace(/[‚Ç¨$¬£kr]/g, '').trim();
        
        // Handle European number format (e.g., "27,95")
        if (price.includes(',') && /,\d{2}(?:\s|$)/.test(price)) {
            price = price.replace(/\./g, '').replace(',', '.');
        } else {
            // Remove thousand separators
            price = price.replace(/,/g, '');
        }
        
        // Convert to number
        const numericPrice = parseFloat(price);
        
        if (isNaN(numericPrice)) {
            console.log('‚ùå Failed to parse price:', priceText);
            return null;
        }
        
        console.log('‚úÖ Parsed price:', { original: priceText, normalized: numericPrice });
        return numericPrice;
    } catch (error) {
        console.error('Error normalizing price:', error);
        return null;
    }
}

// Get current site information
let { price: currentPrice, currency: currentCurrency } = getCurrentPriceAndCurrency();
console.log('Current price:', currentPrice, 'Currency:', currentCurrency);

/* // Convert to EUR for comparison
const currentPriceEUR = currentCurrency === 'EUR' ? currentPrice : currentPrice / EUR_TO_DKK_RATE;
console.log('Price in EUR:', currentPriceEUR); */

const convertEurToDkk = (priceInEur) => priceInEur * EUR_TO_DKK_RATE;
const convertDkkToEur = (priceInDkk) => priceInDkk / EUR_TO_DKK_RATE;





/**
 * Converts a given numeric price from a specified currency to EUR.
 * 
 * @param {number} price - The price to convert.
 * @param {string} currency - Currency code (e.g., 'EUR', 'DKK', 'USD', 'GBP').
 * @returns {number|null} The price in EUR if conversion is possible, otherwise null.
 */
function convertToEUR(price, currency) {
    if (typeof price !== 'number' || isNaN(price)) {
        console.log(`‚ùå Invalid price for conversion: ${price}`);
        return null;
    }

    switch (currency?.toUpperCase()) {
        case 'EUR': return price;
        case 'DKK': return price / EXCHANGE_RATES.EUR_TO_DKK;
        case 'GBP': return price / EXCHANGE_RATES.EUR_TO_GBP;
        case 'USD': return price / EXCHANGE_RATES.EUR_TO_USD;
        default:
            console.log(`‚ùå Unsupported currency: ${currency}, defaulting to EUR`);
            return price; // Default to EUR
    }
}


/* *
 * Validates two prices for "reasonableness" based on user-defined thresholds.
 * 
 * @param {number} currentSitePrice - The price found on the current site.
 * @param {number} comparisonPrice - The "reference" price for comparison (often from your database).
 * @param {string} currentCurrency - The currency of the `currentSitePrice`.
 * @param {string} comparisonCurrency - The currency of the `comparisonPrice`.
 * @param {object} [options] - Optional thresholds/settings.
 * @param {number} [options.lowerMultiplier=0.5] - If current price < comparisonPrice * this, it's "too low."
 * @param {number} [options.upperMultiplier=1.8] - If current price > comparisonPrice * this, it's "too high."
 * @returns {{valid: boolean, reason: string, details?: object}}
 *   - `valid` indicates if the price is within an acceptable range.
 *   - `reason` provides a short explanation.
 *   - `details` can include debug data (converted prices, thresholds, etc.).
 */
function validatePrice(sourcePrice, targetPrice, sourceCurrency = 'EUR', targetCurrency = 'EUR', options = {}) {
    const {
        lowerThreshold = 0.2,  // Price can't be 80% lower
        upperThreshold = 1.8,  // Price can't be 80% higher
        debugLog = true
    } = options;

    // First, ensure we have valid numeric prices
    let sourcePriceNum = parseFloat(sourcePrice);
    let targetPriceNum = parseFloat(targetPrice);

    // Guard clauses for invalid inputs
    if (isNaN(sourcePriceNum) || isNaN(targetPriceNum)) {
        if (debugLog) console.log('‚ùå Invalid price values:', { sourcePrice, targetPrice });
        return {
            isValid: false,
            reason: 'INVALID_PRICES',
            details: { sourcePrice, targetPrice }
        };
    }

    // Convert both prices to EUR for comparison
    const sourcePriceEUR = normalizePriceToEUR(sourcePriceNum, sourceCurrency);
    const targetPriceEUR = normalizePriceToEUR(targetPriceNum, targetCurrency);

    if (sourcePriceEUR === null || targetPriceEUR === null) {
        if (debugLog) console.log('‚ùå Currency conversion failed:', { sourcePriceEUR, targetPriceEUR });
        return {
            isValid: false,
            reason: 'CURRENCY_CONVERSION_FAILED',
            details: { sourcePriceEUR, targetPriceEUR }
        };
    }

    // Calculate thresholds
    const minimumPrice = Number(targetPriceEUR) * lowerThreshold;
    const maximumPrice = Number(targetPriceEUR) * upperThreshold;

    // Ensure all values are numbers before using toFixed
    const sourcePriceEURNum = Number(sourcePriceEUR);
    const targetPriceEURNum = Number(targetPriceEUR);
    const minimumPriceNum = Number(minimumPrice);
    const maximumPriceNum = Number(maximumPrice);

    // Perform validation
    const isTooLow = sourcePriceEURNum < minimumPriceNum;
    const isTooHigh = sourcePriceEURNum > maximumPriceNum;
    const isValid = !isTooLow && !isTooHigh;

    if (debugLog) {
        console.log('Price validation:', {
            sourcePriceEUR: sourcePriceEURNum.toFixed(2),
            targetPriceEUR: targetPriceEURNum.toFixed(2),
            minimumPrice: minimumPriceNum.toFixed(2),
            maximumPrice: maximumPriceNum.toFixed(2),
            isValid,
            isTooLow,
            isTooHigh
        });
    }

    return {
        isValid,
        reason: isValid ? 'VALID' : (isTooLow ? 'TOO_LOW' : 'TOO_HIGH'),
        details: {
            sourcePriceEUR: sourcePriceEURNum.toFixed(2),
            targetPriceEUR: targetPriceEURNum.toFixed(2),
            minimumPrice: minimumPriceNum.toFixed(2),
            maximumPrice: maximumPriceNum.toFixed(2),
            difference: ((sourcePriceEURNum - targetPriceEURNum) / targetPriceEURNum * 100).toFixed(2) + '%'
        }
    };
}

// Helper function to safely convert to number
function safeNumber(value) {
    const num = Number(value);
    return isNaN(num) ? null : num;
}

// Helper function to normalize price to EUR
function normalizePriceToEUR(price, currency) {
    const numPrice = safeNumber(price);
    if (numPrice === null) return null;
    
    switch(currency.toUpperCase()) {
        case 'EUR': return numPrice;
        case 'DKK': return numPrice / EXCHANGE_RATES.EUR_TO_DKK;
        case 'GBP': return numPrice / EXCHANGE_RATES.EUR_TO_GBP;
        case 'USD': return numPrice / EXCHANGE_RATES.EUR_TO_USD;
        default:
            console.warn(`Unsupported currency: ${currency}`);
            return null;
    }
}

// Example usage in displayPrice function:
function displayPrice(responses, identifier, identifierType) {
    const { price: currentPrice, currency: currentCurrency } = getCurrentPriceAndCurrency();
    if (!currentPrice) {
        console.log('‚ùå No current price found');
        return;
    }

    let priceResults = [];

    for (const response of responses) {
        if (!response?.html) continue;
        
        const doc = new DOMParser().parseFromString(response.html, 'text/html');
        const shop = SHOPS.find(s => response.url.includes(s.domain));
        if (!shop) continue;

        const priceElement = doc.querySelector(shop.priceSelector);
        if (!priceElement) continue;

        let priceText = priceElement.textContent.trim();
        const priceData = convertPrice(priceText);

        // Make sure we have valid price data before validation
        if (!priceData.eurValue) {
            console.log(`‚ùå Invalid price data for ${shop.name}`);
            continue;
        }

        // Validate the price
        const validation = validatePrice(
            priceData.eurValue,
            currentPrice,
            'EUR',
            currentCurrency,
            { debugLog: true }
        );

        if (validation.isValid) {
            priceResults.push({
                shop: shop.name,
                price: priceText,
                eurPrice: priceData.eurValue,
                dkkPrice: priceData.dkkValue,
                shopUrl: response.url
            });
        } else {
            console.log(`Price validation failed for ${shop.name}:`, validation.reason);
        }
    }

    if (priceResults.length === 0) {
        console.log("No valid prices found after validation");
        return;
    }

    insertPriceComparison(generateComparisonTable(priceResults, identifierType));
}

// Helper function to normalize price to EUR
function normalizePriceToEUR(price, currency) {
    const numPrice = safeNumber(price);
    if (numPrice === null) return null;
    
    switch(currency.toUpperCase()) {
        case 'EUR': return numPrice;
        case 'DKK': return numPrice / EXCHANGE_RATES.EUR_TO_DKK;
        case 'GBP': return numPrice / EXCHANGE_RATES.EUR_TO_GBP;
        case 'USD': return numPrice / EXCHANGE_RATES.EUR_TO_USD;
        default:
            console.warn(`Unsupported currency: ${currency}`);
            return null;
    }
}

function displayPrice(responses, identifier, identifierType) {
    // Get current page's price
    const currentPriceInfo = getCurrentPriceAndCurrency();
    console.log('Current page price:', currentPriceInfo);

    if (!currentPriceInfo.price) {
        console.log('‚ùå No price found on current page');
        return;
    }

    let priceResults = [];

    for (const response of responses) {
        if (!response?.html) continue;

        const doc = new DOMParser().parseFromString(response.html, 'text/html');
        const shop = SHOPS.find(s => response.url.includes(s.domain));
        if (!shop) continue;

        const priceElement = doc.querySelector(shop.priceSelector);
        if (!priceElement) continue;

        const priceText = priceElement.textContent.trim();
        console.log(`Found price in ${shop.name}:`, priceText);

        // Extract price and currency
        const { price, currency } = extractPriceAndCurrency(priceText);
        if (!price) continue;

        // Validate prices after converting to same currency
        const validation = validatePrice(
            price,
            currentPriceInfo.price,
            currency,
            currentPriceInfo.currency,
            { debugLog: true }
        );

        if (validation.isValid) {
            // Convert to both currencies for display
            const dkkPrice = currency === 'DKK' ? 
                price : 
                price * EXCHANGE_RATES.EUR_TO_DKK;

            const eurPrice = currency === 'EUR' ? 
                price : 
                price / EXCHANGE_RATES.EUR_TO_DKK;

            priceResults.push({
                shop: shop.name,
                price: priceText,
                eurPrice,
                dkkPrice,
                shopUrl: response.url
            });
        } else {
            console.log(`Price validation failed for ${shop.name}:`, validation.reason);
        }
    }

    const productName = findProductName();
    insertPriceComparison(generateComparisonTable(priceResults, identifierType, productName));
}


  
/*     // Try to convert both prices to EUR ‚Äî or declare failure
    const currentPriceEUR = convertToEUR(currentSitePrice, currentCurrency);
    const comparisonPriceEUR = convertToEUR(comparisonPrice, comparisonCurrency);
  
    if (currentPriceEUR == null || comparisonPriceEUR == null) {
      console.log('‚ùå Failed to convert one or both prices to EUR');
      return {
        valid: false,
        reason: 'CURRENCY_CONVERSION_FAILED',
        details: {
          currentCurrency,
          comparisonCurrency,
          currentPriceEUR,
          comparisonPriceEUR
        }
      };
    } */
  
/*     // Check thresholds
    const tooLow = currentPriceEUR < (comparisonPriceEUR * lowerMultiplier);
    const tooHigh = currentPriceEUR > (comparisonPriceEUR * upperMultiplier);
  
    if (tooLow || tooHigh) {
      console.log('‚ö†Ô∏è Price validation failed:', {
        currentPriceEUR: currentPriceEUR.toFixed(2),
        comparisonPriceEUR: comparisonPriceEUR.toFixed(2),
        tooLow,
        tooHigh
      });
      return {
        valid: false,
        reason: tooLow ? 'TOO_LOW' : 'TOO_HIGH',
        details: {
          currentPriceEUR,
          comparisonPriceEUR,
          lowerThreshold: comparisonPriceEUR * lowerMultiplier,
          upperThreshold: comparisonPriceEUR * upperMultiplier
        }
      };
    } */
  
/*     console.log('‚úÖ Price validation passed:', {
      currentPriceEUR: currentPriceEUR.toFixed(2),
      comparisonPriceEUR: comparisonPriceEUR.toFixed(2)
    });
  
    return {
      valid: true,
      reason: 'OK',
      details: {
        currentPriceEUR,
        comparisonPriceEUR
      }
    };
  } */

function detectUrlChange() {
    let lastUrl = location.href;

    const observer = new MutationObserver(() => {
        if (location.href !== lastUrl) {
            console.log('üîÑ URL changed (Detected by MutationObserver):', location.href);
            lastUrl = location.href;
            handleNavigation(); // Ensure handleNavigation is triggered
        }
    });

    observer.observe(document.body, { childList: true, subtree: true });
}

detectUrlChange();


// ==SHOPS==
const SHOPS = [
    {
        name: "Bike-Discount",
        url: "https://www.bike-discount.de/en/search?sSearch=",
        priceSelector: ".price--default, [data-test='product-price'], .price",
        gtinSelectors: [".netz-ean", "[data-ean]", ".pd-ean"],
        domain: "bike-discount.de"
    },
    {
        name: "Bike-Components",
        url: "https://www.bike-components.de/en/s/?keywords=",
        priceSelector: ".price.site-price",
        gtinSelectors: [],
        domain: "bike-components.de"
    },
    {
        name: "Cykelgear",
        url: "https://cykelgear.dk/search?q=",
        priceSelector: ".text-lg.md\\:text-xl.leading-5.font-semibold.text-orange.whitespace-nowrap",
        gtinSelectors: [],
        domain: "cykelgear.dk"
    },
    {
        name: "Bikable",
        url: "https://www.bikable.com/search?q=",
        priceSelector: ".bikable-price-selector",
        gtinSelectors: [],
        domain: "bikable.com"
    },
{
    name: "Cykelshoppen",
    url: "https://cykelshoppen.dk/search?query=",
    priceSelector: ".price-purchase",
    gtinSelectors: [
        {
            type: "jsonld",
            paths: ["gtin", "gtin13", "gtin8", "gtin12", "gtin14"]  // Check all possible GTIN properties
        }
    ],
    domain: "cykelshoppen.dk"
}
];

 
function getCurrentPriceAndCurrency() {
    console.log('Current site:', productInfo.shop.domain);
    
    // Return price info if we already have it
    if (productInfo.price.amount && productInfo.price.currency) {
        return {
            price: productInfo.price.amount,
            currency: productInfo.price.currency
        };
    }

    // If not, get it from the current site
    const currentShop = SHOPS.find(shop => productInfo.shop.domain.includes(shop.domain));
    if (!currentShop) {
        console.log('‚ùå Not on a supported site');
        return { price: null, currency: null };
    }

    const priceElement = document.querySelector(currentShop.priceSelector);
    if (!priceElement) {
        console.log(`‚ùå No price element found with selector: ${currentShop.priceSelector}`);
        return { price: null, currency: null };
    }

    const priceText = priceElement.textContent.trim();
    const { price, currency } = extractPriceAndCurrency(priceText);
    
    if (price) {
        // Update productInfo with the found price
        productInfo.price = {
            amount: price,
            currency: currency,
            rawText: priceText,
            source: 'DOM'
        };
        return { price, currency };
    }

    return { price: null, currency: null };
}
 
function getJSONLDPrice() {
    try {
        const scripts = document.querySelectorAll('script[type="application/ld+json"]');
        for (const script of scripts) {
            const data = JSON.parse(script.textContent);
            
            // Handle both single product and array of products
            const products = Array.isArray(data) ? data : [data];
            
            for (const product of products) {
                if (product['@type'] === 'Product' && product.offers) {
                    const offers = Array.isArray(product.offers) 
                        ? product.offers[0] 
                        : product.offers;

                    if (offers.price && offers.priceCurrency) {
                        const price = parseFloat(offers.price);
                        if (!isNaN(price)) {
                            return {
                                price,
                                currency: offers.priceCurrency
                            };
                        }
                    }
                }
            }
        }
    } catch (e) {
        console.error('Error parsing JSON-LD:', e);
    }
    return { price: null, currency: null };
}
function extractPriceAndCurrency(priceText) {
    if (!priceText) return { price: null, currency: null };

    // Clean the text
    let text = priceText.trim();
    
    // Remove "from" or "fra" prefix
    text = text.replace(/^(from|fra)\s+/i, '');

    // Determine currency
    let currency = 'EUR';
    if (text.includes('kr') || text.includes('DKK')) currency = 'DKK';

    // Clean up the price
    let price = text.replace(/[‚Ç¨$¬£kr]/g, '').trim();

    // Handle European number format
    if (price.includes(',') && /,\d{2}(?:\s|$)/.test(price)) {
        price = price.replace(/\./g, '').replace(',', '.');
    } else {
        price = price.replace(/,/g, '');
    }

    const numericPrice = parseFloat(price);
    if (isNaN(numericPrice)) {
        console.log('‚ùå Failed to parse price:', priceText);
        return { price: null, currency: null };
    }

    return { price: numericPrice, currency };
}


function validatePrice(sourcePrice, targetPrice, sourceCurrency = 'EUR', targetCurrency = 'EUR', options = {}) {
    const {
        lowerThreshold = 0.2,  // Price can't be 80% lower
        upperThreshold = 1.8,  // Price can't be 80% higher
        debugLog = true
    } = options;

    // Convert prices to numbers if they're strings
    const sourcePriceNum = typeof sourcePrice === 'string' ? normalizePrice(sourcePrice) : sourcePrice;
    const targetPriceNum = typeof targetPrice === 'string' ? normalizePrice(targetPrice) : targetPrice;

    if (debugLog) {
        console.log('Validating prices:', {
            sourcePrice: sourcePriceNum,
            sourceCurrency,
            targetPrice: targetPriceNum,
            targetCurrency
        });
    }

    // Guard clauses for invalid inputs
    if (sourcePriceNum === null || targetPriceNum === null) {
        console.log('‚ùå Invalid price values:', { sourcePrice, targetPrice });
        return {
            isValid: false,
            reason: 'INVALID_PRICES',
            details: { sourcePrice, targetPrice }
        };
    }

    // Convert both prices to EUR for comparison
    const sourcePriceEUR = convertToEUR(sourcePriceNum, sourceCurrency);
    const targetPriceEUR = convertToEUR(targetPriceNum, targetCurrency);

    if (sourcePriceEUR === null || targetPriceEUR === null) {
        console.log('‚ùå Currency conversion failed:', { sourcePriceEUR, targetPriceEUR });
        return {
            isValid: false,
            reason: 'CURRENCY_CONVERSION_FAILED',
            details: { sourcePriceEUR, targetPriceEUR }
        };
    }

    // Calculate thresholds
    const minimumPrice = targetPriceEUR * lowerThreshold;
    const maximumPrice = targetPriceEUR * upperThreshold;

    // Perform validation
    const isTooLow = sourcePriceEUR < minimumPrice;
    const isTooHigh = sourcePriceEUR > maximumPrice;
    const isValid = !isTooLow && !isTooHigh;

    if (debugLog) {
        console.log('Price validation:', {
            sourcePriceEUR,
            targetPriceEUR,
            minimumPrice,
            maximumPrice,
            isValid,
            isTooLow,
            isTooHigh
        });
    }

    return {
        isValid,
        reason: isValid ? 'VALID' : (isTooLow ? 'TOO_LOW' : 'TOO_HIGH'),
        details: {
            sourcePriceEUR,
            targetPriceEUR,
            minimumPrice,
            maximumPrice,
            difference: ((sourcePriceEUR - targetPriceEUR) / targetPriceEUR * 100).toFixed(2) + '%'
        }
    };
}


function findGTIN() {
        console.log('üîÑ Clearing old GTINs before fetching new ones...');
    
    // Reset GTIN list before extracting new GTINs
    productInfo.gtin = [];
	
	const gtinSelectors = [
        '[itemprop="gtin13"]', '[itemprop="gtin"]', '[itemprop="gtin8"]',
        '[itemprop="gtin12"]', '[itemprop="gtin14"]', '.netz-ean',
        '[data-ean]', 'span[itemprop="productID"]', 'meta[property="product:ean"]',
        'meta[property="og:ean"]', '.ean-code', '.product-ean',
        '[data-gtin]', '.gtin-code', '.product-gtin', 'span.ean', 'div.ean',
        'p.ean', '[data-product-code]', '[data-barcode]', 'meta[name="gtin"]',
        'meta[name="ean"]', '[itemprop="productID"]', '.barcode-number',
        '.product-barcode', 'span[data-ean]', 'div[data-gtin]', '.code-ean',
        '.sku-ean', '[data-product-ean]', 'meta[property="product:barcode"]',
        '.gtin', '.product-identifier', '[data-identifier]', 'span.product-code',
        'div.product-code'
    ];

    console.log("üîç S√∏ger efter GTIN...");

    // 1Ô∏è‚É£ HTML Selectors
    for (const selector of gtinSelectors) {
        const element = document.querySelector(selector);
        if (element) {
            let gtin = element.textContent?.trim().replace(/[^0-9]/g, '') || '';
            let attrValue = element.getAttribute("content")?.trim() ||
                            element.getAttribute("data-ean")?.trim() ||
                            element.getAttribute("data-gtin")?.trim() ||
                            element.getAttribute("value")?.trim() || '';
            let finalGTIN = attrValue || gtin;
            
            if (finalGTIN.length >= 8 && finalGTIN.length <= 14) {
                console.log(`‚úÖ Fundet GTIN: ${finalGTIN} (Selector: '${selector}')`);
                productInfo.gtin.push({
                    value: finalGTIN,
                    source: `HTML Selector: ${selector}`,
                    url: window.location.href
                });
            }
        }
    }

    console.log("üîç Ingen GTIN fundet i HTML. Tjekker JSON-LD...");

    // 2Ô∏è‚É£ JSON-LD Scripts
 const scripts = document.querySelectorAll('script[type="application/ld+json"]');
    for (let i = 0; i < scripts.length; i++) {
        try {
            const jsonData = JSON.parse(scripts[i].textContent);
            let gtin = extractGTINFromJSON(jsonData);
            if (gtin) {
                console.log(`‚úÖ Fundet GTIN i JSON-LD script #${i + 1}: ${gtin}`);
                productInfo.gtin.push({
                    value: gtin,
                    source: `JSON-LD Script #${i + 1}`,
                    url: window.location.href
                });
            }
        } catch (e) {
            console.error(`‚ùå Fejl ved parsing af JSON-LD script #${i + 1}:`, e);
        }
    }

    console.log("Found GTINs:", productInfo.gtin);
    
    // Return the first GTIN found (for compatibility with existing code)
    return productInfo.gtin.length > 0 ? productInfo.gtin[0].value : null;
}

function extractGTINFromJSON(json) {
    if (!json) return null;

    if (json.gtin13) return json.gtin13;
    if (json.gtin) return json.gtin;
    if (json.gtin8) return json.gtin8;
    if (json.gtin12) return json.gtin12;
    if (json.gtin14) return json.gtin14;
    if (json.productID && json.productID.match(/^\d{8,14}$/)) return json.productID;
    
    if (json.offers) {
        if (Array.isArray(json.offers)) {
            for (const offer of json.offers) {
                let gtin = extractGTINFromJSON(offer);
                if (gtin) return gtin;
            }
        } else {
            let gtin = extractGTINFromJSON(json.offers);
            if (gtin) return gtin;
        }
    }

    if (Array.isArray(json)) {
        for (const obj of json) {
            let gtin = extractGTINFromJSON(obj);
            if (gtin) return gtin;
        }
    }

    return null;
}

function waitForGTIN(callback, maxRetries = 10, interval = 500) {
    let attempts = 0;
    let observer = null;
    
    console.log("üîç Starting GTIN search...");

    const checkGTIN = () => {
        let gtin = findGTIN();
        if (gtin) {
            console.log(`‚úÖ GTIN found after ${attempts + 1} attempts: ${gtin}`);
            if (observer) observer.disconnect(); // Stop observing if GTIN is found
            callback(gtin);
        } else if (attempts < maxRetries) {
            attempts++;
            console.log(`üîÑ GTIN not found. Retrying... (${attempts}/${maxRetries})`);
            setTimeout(checkGTIN, interval);
        } else {
            console.log("‚ùå GTIN not found after max retries. Watching for DOM changes...");
            
            // Ensure we only attach one observer at a time
            if (!observer) {
                observer = new MutationObserver(() => {
                    let dynamicGTIN = findGTIN();
                    if (dynamicGTIN) {
                        console.log(`‚úÖ GTIN dynamically found: ${dynamicGTIN}`);
                        observer.disconnect();
                        callback(dynamicGTIN);
                    }
                });

                observer.observe(document.body, { childList: true, subtree: true });
            }
        }
    };

    checkGTIN();
}

// üî• Start GTIN detection with automatic retries & DOM watching
waitForGTIN(gtin => console.log("GTIN found dynamically:", gtin));




// Function to find and store Price
function findPrice() {
    if (priceFound) return productData.price;  // If already found, return it

    const priceSelector = '.price .amount';  // Fallback selector
    const priceElement = document.querySelector(priceSelector);
    if (priceElement) {
        const priceValue = priceElement.textContent.trim().replace('‚Ç¨', '').trim();
        productData.price = priceValue;
        priceFound = true;  // Mark as found
        console.log('Price found:', priceValue);
        return priceValue;
    }

    console.log('Price No match');
    return null;
}

// Function to find and store MPN
function findMPN() {
    const mpnSelectors = [
        '[itemprop="mpn"]',
        '[itemprop="sku"]',
        '.product-id',
        '.netz-ean',  // Bike-Discount specific
        '[data-ean]',
        'span[itemprop="productID"]'
    ];

    for (const selector of mpnSelectors) {
        const mpnElement = document.querySelector(selector);
        if (mpnElement) {
            const mpnValue = mpnElement.textContent?.trim() || 
                             mpnElement.getAttribute('content') || 
                             mpnElement.getAttribute('data-ean');

            if (mpnValue) {
                console.log(`‚úÖ Found MPN: ${mpnValue} (Selector: '${selector}')`);
                return mpnValue; // STOP once we find a valid MPN
            }
        }
    }

    console.log('‚ùå No MPN found');
    return null;
}
 
const PriceTracker = (function() {
    async function trackClick(store, productUrl, productName, price, gtin, mpn) {
        try {
            const clickData = {
                store: store,
                productUrl: productUrl,
                productName: productName,
                price: price,
                gtin: gtin,
                mpn: mpn,
                referringUrl: window.location.href  
            };
            
            console.log('Sending data:', clickData); 
            
            const response = await fetch('https://jrgrafisk.dk/php-endpoint.php', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(clickData)
            });
            
           
            const responseText = await response.text();
            console.log('Raw response:', responseText);
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}, response: ${responseText}`);
            }
            
            try {
                const result = JSON.parse(responseText);
                console.log('Click tracked successfully:', result);
            } catch (parseError) {
                console.error('JSON Parse Error:', parseError);
                console.error('Invalid JSON response:', responseText);
            }
        } catch (error) {
            console.error('Error tracking click:', {
                message: error.message,
                error: error
            });
        }
    }

function handleClick(event) {
    event.preventDefault();  // Prevent default only temporarily
    const link = event.currentTarget;
    
    try {
        const store = link.getAttribute('data-store');
        const url = link.getAttribute('data-url');
        const name = link.getAttribute('data-name');
        const price = link.getAttribute('data-price');
        const gtin = link.getAttribute('data-gtin');
        const mpn = link.getAttribute('data-mpn');

        if (!store || !url) {
            console.error('Missing required tracking data');
            window.location.href = url;  // Continue with navigation
            return;
        }

        // Track the click
        trackClick(store, url, name, price, gtin, mpn)
            .finally(() => {
                // Continue with navigation after tracking (or if tracking fails)
                window.location.href = url;
            });
    } catch (error) {
        console.error('Error in click handler:', error);
        // Still navigate even if there's an error
        window.location.href = link.getAttribute('data-url');
    }
}

    function attachTrackingHandlers() {
        try {
            const links = document.querySelectorAll('.track-click');
            console.log('Found tracking links:', links.length);
            
            links.forEach(link => {
                // Remove existing handlers to prevent duplicates
                link.removeEventListener('click', handleClick);
                link.addEventListener('click', handleClick);
            });
        } catch (error) {
            console.error('Error attaching tracking handlers:', error);
        }
    }

    return {
        attachTrackingHandlers: attachTrackingHandlers,
        // Expose for debugging
        _debug: {
            trackClick,
            handleClick
        }
    };
})();

function addUTMParameters(originalUrl) {
    try {
        // Use the findGTIN() function to get the GTIN value
        const gtinValue = findGTIN();

        // Use findMPN() as fallback if no GTIN found
        const mpnValue = findMPN();

        const productName = findProductName() || 'unknown_product';

        // Search identifier is GTIN if available, otherwise MPN
        const searchIdentifier = gtinValue || mpnValue || 'unknown_identifier';

        // Define UTM parameters
        const utm = {
            utm_source: 'Price Comparison Extension',
            utm_medium: 'price_comparison',
            utm_campaign: 'product_search',
            utm_content: encodeURIComponent(productName),
            utm_term: searchIdentifier
        };

        // Create a URL object from the original URL
        const urlObject = new URL(originalUrl);

        // Append UTM parameters to the URL
        Object.entries(utm).forEach(([key, value]) => {
            urlObject.searchParams.append(key, value);
        });

        // Optional: Add additional tracking parameters
        urlObject.searchParams.append('ref', 'cykelgear_price_comparison');
        urlObject.searchParams.append('tracking_id', Math.random().toString(36).substring(2, 15) + 
                                                     Math.random().toString(36).substring(2, 15));

        // Return the URL with appended UTM parameters
        return urlObject.toString();
    } catch (error) {
        console.error('Error adding UTM parameters:', error);
        return originalUrl;  // Return the original URL in case of error
    }
}


function generateTrackingId() {
    return Math.random().toString(36).substring(2, 15) + 
           Math.random().toString(36).substring(2, 15);
}

/* function findMPN() {
    const mpnSelectors = [
        '[itemprop="mpn"]',
        '[itemprop="sku"]',
        '.product-id',
        'span[itemprop="productID"]',  // Refined selector for product ID
        '.netz-ean',  // Bike-Discount specific
        '[data-ean]'
    ];

    // Loop through selectors
    for (const selector of mpnSelectors) {
        const mpnElement = document.querySelector(selector);
        if (mpnElement) {
            // Log the HTML content of the found MPN element (only for debugging)
            console.log('MPN element HTML:', mpnElement.outerHTML);

            // Retrieve MPN value from text content, content attribute, or data-ean attribute
            const mpnValue = mpnElement.textContent.trim() || 
                             mpnElement.getAttribute('content') || 
                             mpnElement.getAttribute('data-ean');
                             
            // Log found MPN value
            console.log(`MPN found with selector ${selector}:`, mpnValue);
            
            // Return the value if it's not empty
            if (mpnValue) return mpnValue; 
        }
    }

    // If no MPN found, log and return null
    console.log('No MPN found');
    return null;
} */

/* function extractProductData() {
    const gtin = findGTIN(); // Prioritize GTIN

    if (gtin) {
        console.log('Using GTIN:', gtin);
    } else {
        console.log('GTIN No match, checking for MPN...');
        const mpn = findMPN(); // Only check MPN if GTIN is not available

        if (mpn) {
            console.log('Using MPN:', mpn);
        } else {
            console.log('No GTIN or MPN found, cannot proceed.');
        }
    }
} */


function checkIdentifiers() {
    findGTIN();  // This now collects GTINs into productInfo
    findMPN();   // This should collect MPNs into productInfo

    console.log('Found product identifiers:', {
        gtins: productInfo.gtin,
        mpns: productInfo.mpn
    });

    // If you still need a single primary identifier for some purposes
    return {
        primaryIdentifier: productInfo.gtin[0]?.value || productInfo.mpn[0]?.value || null,
        type: productInfo.gtin[0] ? 'GTIN' : (productInfo.mpn[0] ? 'MPN' : null)
    };
}


function convertPrice(priceText) {
    if (!priceText) return { convertedPrice: "No match", eurValue: null, dkkValue: null };

    try {
        // Normalize the price first
        const numericPrice = normalizePrice(priceText);
        if (numericPrice === null) {
            return { convertedPrice: "No match", eurValue: null, dkkValue: null };
        }

        // Determine if it's EUR or DKK based on the original text
        const isEUR = priceText.includes('‚Ç¨');
        
        if (isEUR) {
            return {
                convertedPrice: `${(numericPrice * EXCHANGE_RATES.EUR_TO_DKK).toFixed(2)}`,
                eurValue: numericPrice,
                dkkValue: numericPrice * EXCHANGE_RATES.EUR_TO_DKK
            };
        }

        // If price contains 'kr', it's already DKK
        if (priceText.includes('kr')) {
            return {
                convertedPrice: numericPrice.toFixed(2),
                eurValue: (numericPrice / EXCHANGE_RATES.EUR_TO_DKK).toFixed(2),
                dkkValue: numericPrice
            };
        }

        // Default case: assume it's in EUR
        return {
            convertedPrice: `${(numericPrice * EXCHANGE_RATES.EUR_TO_DKK).toFixed(2)}`,
            eurValue: numericPrice,
            dkkValue: numericPrice * EXCHANGE_RATES.EUR_TO_DKK
        };
    } catch (error) {
        console.error('Error converting price:', error);
        return { convertedPrice: "No match", eurValue: null, dkkValue: null };
    }
}


function findProductName() {
    const productNameSelectors = [
        'h1.product-title',
        'h1[itemprop="name"]',
        'h1',
        '.product--title',  // Bike-Discount specific
        '.product-details h1'
    ];

    for (const selector of productNameSelectors) {
        const nameElement = document.querySelector(selector);
        if (nameElement) {
            // Get and clean up product name (trim and normalize spaces)
            const productName = nameElement.textContent.trim().replace(/\s+/g, ' ');
            
            // If the product name is empty after trimming, skip this selector
            if (productName) {
                console.log(`Product name found with selector ${selector}:`, productName);
                return productName;
            } else {
                console.log(`Empty product name found with selector ${selector}`);
            }
        }
    }

    console.log('Could not find product name');
    return null;
}




/* function findMPN() {
    // Try to get the MPN (Sku) from the <span itemprop="sku">
    const mpn = document.querySelector('[itemprop="sku"]');
    if (mpn) {
        const mpnValue = mpn.textContent.trim();
        if (mpnValue) {
            console.log('MPN found:', mpnValue);
            return mpnValue;
        } else {
            console.log('MPN found but it was empty after trimming');
        }
    }

    // Fallback: Try additional selectors if MPN is No match in the primary selector
    const fallbackSelectors = [
        '.product-id', 
        '[data-sku]', 
        '.netz-ean',  // Bike-Discount specific
        'span[itemprop="productID"]'
    ];

    for (const selector of fallbackSelectors) {
        const fallbackMPN = document.querySelector(selector);
        if (fallbackMPN) {
            const fallbackMPNValue = fallbackMPN.textContent.trim() || 
                                      fallbackMPN.getAttribute('content') || 
                                      fallbackMPN.getAttribute('data-ean');
            if (fallbackMPNValue) {
                console.log('MPN found via fallback selector:', selector, fallbackMPNValue);
                return fallbackMPNValue;
            } else {
                console.log(`Fallback MPN found with selector ${selector}, but value was empty`);
            }
        }
    }

    // If no MPN is found, return null
    console.log('No MPN found');
    return null;
} */


// Main extraction function
function extractProductData() {
    const gtin = findGTIN(); // Prioritize GTIN
    
    // Only check MPN if GTIN was No match
    let mpn = null;
    if (!gtin) {
        mpn = findMPN(); // Check MPN if no GTIN
    }

    // Log the results
    if (gtin) {
        console.log('Using GTIN:', gtin);
    } else if (mpn) {
        console.log('Using MPN:', mpn);
    } else {
        console.log('No GTIN or MPN found, cannot proceed.');
    }
}

function validateGTIN(gtin) {
    if (!gtin) return false;
    const cleanGTIN = gtin.toString().replace(/[^0-9]/g, '');
    return cleanGTIN.length >= 8 && cleanGTIN.length <= 14;
}



// Call the main extraction function when the page is loaded
extractProductData();

function findProductData() {
    const scripts = document.querySelectorAll('script[type="application/ld+json"]');
    for (const script of scripts) {
        try {
            const data = JSON.parse(script.textContent);
            
            // H√•ndter b√•de enkelte produkter og lister
            const products = Array.isArray(data) ? data : [data];
            
            for (const product of products) {
                if (product['@type'] === 'Product') {
                    const gtin = product.gtin13 || product.gtin14 || product.gtin12 || product.gtin8 || product.gtin;
                    const price = product.offers?.price;
                    if (gtin || price) {
                        console.log('Found product data in JSON-LD:', { gtin, price });
                        return { gtin, price };
                    }
                }
            }
        } catch (e) {
            console.error('Error parsing JSON-LD:', e);
        }
    }
    return null;
}

function findPrice() {
    const priceSelectors = [
        // Strukturerede data
        '[itemprop="price"]',
        '[property="og:price:amount"]',
        'meta[property="product:price:amount"]',
        
        // Almindelige klasser
        '.price .amount',
        '.product-price',
        '.price--default',
        '.current-price',
        '.actual-price',
        '.sale-price',
        
        // Site-specifikke selektorer
        '#netz-price',
        '.price.site-price',
        '.text-lg.md\\:text-xl.leading-5.font-semibold.text-orange'
    ];

    for (const selector of priceSelectors) {
        const elements = document.querySelectorAll(selector);
        for (const element of elements) {
            const priceText = element.textContent || element.getAttribute('content');
            if (priceText) {
                // Rens prisen for alt undtagen tal og decimaltegn
                const cleanPrice = priceText.replace(/[^0-9.,]/g, '').replace(',', '.');
                const price = parseFloat(cleanPrice);
                if (!isNaN(price) && price > 0) {
                    return price;
                }
            }
        }
    }

    return null;
}


// Main Function to Run on Page Load
function extractProductData() {
    const gtin = findGTIN();
    const price = findPrice();

    // Check if GTIN is missing or price is invalid
    if (!gtin) {
        console.log('GTIN No match, cannot proceed.');
        return;
    }

    if (isNaN(price)) {
        console.log('Invalid price format, cannot proceed.');
        return;
    }

    // Use the GTIN and price for further processing
    console.log('GTIN:', gtin);
    console.log('Price:', price)
}


// Call the main function when the page is loaded or ready
extractProductData();

async function searchWithIdentifier(identifier, idType) {
    console.log(`üîç Starter s√∏gning efter ${identifier} (${idType})`);

    const shopPromises = SHOPS.map(shop => new Promise(resolve => {
        console.log(`üîé S√∏ger p√• ${shop.name}...`);
        browser.runtime.sendMessage({ 
            action: 'findPrice', 
            identifier: identifier, 
            url: shop.url + identifier 
        }, response => {
            if (browser.runtime.lastError) {
                console.error(`‚ùå Fejl ved s√∏gning p√• ${shop.name}:`, browser.runtime.lastError);
                resolve({ html: null, url: shop.url + identifier });
                return;
            }
            resolve(response);
        });
    }));

    const responses = await Promise.all(shopPromises);
    return { responses, foundPrice: responses.some(res => res.html) };
}




function findGTINFromJSONLD() {
    try {
        const scripts = Array.from(document.querySelectorAll('script[type="application/ld+json"]'));
        for (const script of scripts) {
            try {
                const data = JSON.parse(script.textContent);
                if (data['@type'] === 'Product' && data.gtin13) {
                    return data.gtin13;
                }
            } catch (e) {
                console.error('Error parsing individual JSON-LD script:', e);
            }
        }
    } catch (e) {
        console.error('Error accessing scripts:', e);
    }
    return null;
}


// Hovedfunktion til at finde og sammenligne pris
async function findAndComparePrice() {
    console.log('üîç Starter prissammenligning...');
 
 // Clear previous price data before fetching new ones
    let priceResults = [];

    const allowedShops = SHOPS.map(shop => shop.domain);
const isAllowed = allowedShops.some(domain => window.location.href.includes(domain));

if (!isAllowed) {
    console.log('‚ùå Forkert side, stopper.');
    return;
}

    // Find produktnavn
    const productName = findProductName();
    console.log('üìå Produktnavn fundet:', productName);

    // Find GTIN og MPN
    let gtin = findGTIN();
    let mpn = findMPN();
    let searchIdentifier = gtin || mpn;
    let identifierType = gtin ? "GTIN" : "MPN";

    console.log(`üîç Bruger ${identifierType}:`, searchIdentifier);

    // Hvis ingen GTIN eller MPN findes, vis Google-s√∏gning
    if (!searchIdentifier) {
        console.log('‚ùå Ingen GTIN eller MPN fundet.');
        insertPriceComparison(`
            <h4 style="display: inline; font-weight: 700;">Prissammenligning</h4>
            <p>Vi kunne ikke finde en stegkode eller varenummer for dette produkt.</p>
            ${productName ? 
                `<p><a href="https://www.google.com/search?q=${encodeURIComponent(productName)}" target="_blank" title="S√∏g efter ${(productName)} p√• Google">Pr√∏v en Google-s√∏gning üîç</a></p>` : 
                ''}
        `);
        return;
    }

    // üîç Undg√• at s√∏ge efter samme GTIN flere gange
    if (processedGTINs.has(searchIdentifier)) {
        console.log(`‚ö†Ô∏è ${identifierType} ${searchIdentifier} er allerede behandlet. Skipping.`);
        return;
    }

    processedGTINs.set(searchIdentifier, true); // Mark√©r som behandlet

// üîÑ **Clear previous prices before fetching new ones**
    document.querySelectorAll('.price-comparison-table').forEach(el => el.remove());

    // üîç Fetch new prices
    const { responses: primaryResponses, foundPrice: primaryFound } = await searchWithIdentifier(searchIdentifier, identifierType);



    // Hvis vi s√∏gte med GTIN, men ikke fandt en pris, pr√∏v MPN som fallback
    if (identifierType === "GTIN" && !primaryFound && mpn) {
        console.log('‚ùå Ingen priser fundet med GTIN. Pr√∏ver MPN fallback...');
        const { responses: fallbackResponses, foundPrice: fallbackFound } = await searchWithIdentifier(mpn, "MPN");

        if (fallbackFound) {
            identifierType = "MPN (fra GTIN)";
            searchIdentifier = mpn;
            displayPrice(fallbackResponses, searchIdentifier, identifierType);
            return;
        }
    }

    // Hvis vi fandt en pris, vis den p√• siden
    displayPrice(primaryResponses, searchIdentifier, identifierType);
}



// Call the main function when the page is loaded or ready
findAndComparePrice();


function getCurrentPriceAndCurrency() {
    // Try JSON-LD first
    const scripts = document.querySelectorAll('script[type="application/ld+json"]');
    for (const script of scripts) {
        try {
            const data = JSON.parse(script.textContent);
            if (data['@type'] === 'Product' && data.offers) {
                const offers = Array.isArray(data.offers) ? data.offers[0] : data.offers;
                if (offers.price && offers.priceCurrency) {
                    const price = parseFloat(offers.price);
                    if (!isNaN(price)) {
                        console.log('‚úÖ Found price in JSON-LD:', { price, currency: offers.priceCurrency });
                        return { price, currency: offers.priceCurrency };
                    }
                }
            }
        } catch (e) {
            console.error('Error parsing JSON-LD:', e);
        }
    }

    // Try DOM selectors
    const currentShop = SHOPS.find(shop => window.location.hostname.includes(shop.domain));
    if (!currentShop) {
        console.log('‚ùå Not on a supported site');
        return { price: null, currency: null };
    }

    const priceElement = document.querySelector(currentShop.priceSelector);
    if (!priceElement) {
        console.log('‚ùå No price element found');
        return { price: null, currency: null };
    }

    const priceText = priceElement.textContent.trim();
    const price = normalizePrice(priceText);
    const currency = detectCurrency(priceText);

    if (price !== null) {
        console.log('‚úÖ Found price in DOM:', { price, currency });
        return { price, currency };
    }

    console.log('‚ùå No valid price found');
    return { price: null, currency: null };
}

function displayPrice(responses, identifier, identifierType) {
    // Get the reference price from current page
    const { price: currentPrice, currency: currentCurrency } = getCurrentPriceAndCurrency();
    
    let priceResults = [];

    for (const response of responses) {
        if (!response?.html) continue;
        
        const doc = new DOMParser().parseFromString(response.html, 'text/html');
        const shop = SHOPS.find(s => response.url.includes(s.domain));
        
        if (!shop) continue;

        const priceElement = doc.querySelector(shop.priceSelector);
        if (!priceElement) continue;

        let priceText = priceElement.textContent.trim();
        const priceData = convertPrice(priceText);

        // Validate the price
        const validation = validatePrice(
            priceData.eurValue,
            currentPrice,
            'EUR',
            currentCurrency,
            { debugLog: true }
        );

        if (validation.isValid) {
            priceResults.push({
                shop: shop.name,
                price: priceText,
                eurPrice: priceData.eurValue,
                dkkPrice: priceData.dkkValue,
                shopUrl: response.url
            });
        } else {
            console.log(`Price validation failed for ${shop.name}:`, validation.reason);
        }
    }

    if (priceResults.length === 0) {
        console.log("No valid prices found after validation");
        return;
    }

    insertPriceComparison(generateComparisonTable(priceResults, identifierType));
}
function generateNoProductsMessage(productName) {
    return `
        <div class="no-products-message">
            <h4>No products found for ${productName || 'this item'}</h4>
            <p>We couldn't find any matching products at the moment. Please try again later or refine your search.</p>
        </div>
    `;
}

const comparisonMessage = noProductsFound ? 
    generateNoProductsMessage(productName) : 
    generateComparisonTable(productName, identifierType);

if (!document.querySelector('.price-comparison-table')) {
    insertPriceComparison(comparisonMessage);
}

function processShopResponse(doc, url) {
    const shop = SHOPS.find(s => url.includes(s.domain));
    if (!shop) {
        console.log("üö® Unknown shop:", url);
        return { shop: "Unknown", price: null, eurPrice: "No match", dkkPrice: "No match", shopUrl: url };
    }

    const priceElement = doc.querySelector(shop.priceSelector);
    if (!priceElement) {
        console.log(`‚ùå No price element found for ${shop.name}`);
        return { shop: shop.name, price: null, eurPrice: "No match", dkkPrice: "No match", shopUrl: url };
    }

    let priceText = priceElement.textContent.trim();
    // Remove "from" or "fra" (case insensitive)
    priceText = priceText.replace(/^(from|fra)\s*/i, "").trim();

    const priceData = convertPrice(priceText);
    
    console.log(`‚úÖ Price found on ${shop.name}:`, {
        originalText: priceText,
        eurValue: priceData.eurValue,
        dkkValue: priceData.dkkValue
    });

    return {
        shop: shop.name,
        price: priceText,
        eurPrice: priceData.eurValue || "No match",
        dkkPrice: priceData.dkkValue ? `${priceData.dkkValue.toFixed(2)}` : "No match",
        shopUrl: url
    };
}


function setupProductInfo() {
    // Get current URL info
    const currentUrl = window.location.href;
    const currentDomain = window.location.hostname;
    const timestamp = new Date().toISOString();

    // Get current shop info from SHOPS array
    const currentShop = SHOPS.find(shop => currentDomain.includes(shop.domain));

    // Get price information
    const { price, currency } = getCurrentPriceAndCurrency();

    // Get product name
    const productName = findProductName();

    // Initialize productInfo
    productInfo = {
        gtin: [],        // Will be filled by findGTIN()
        mpn: [],         // Will be filled by findMPN()
        shop: {
            name: currentShop?.name || '',
            url: currentUrl,
            domain: currentDomain
        },
        price: {
            amount: price,
            currency: currency,
            rawText: '',  // Will be filled by getCurrentPriceAndCurrency
            source: ''    // Will be filled by getCurrentPriceAndCurrency
        },
        product: {
            name: productName,
            category: '',  // Could be added if you have category detection
            brand: ''     // Could be added if you have brand detection
        },
        referrer: {
            url: currentUrl,
            price: price,
            timestamp: timestamp
        },
        detectedOn: currentDomain,
        foundTimestamp: timestamp
    };

    // Find identifiers
    findGTIN();  // This will populate productInfo.gtin
    findMPN();   // This will populate productInfo.mpn

    console.log('Product Info Setup Complete:', productInfo);
}











function generateComparisonTable(priceResults, identifierType, productName = null, gtin = null, mpn = null) {
    console.log("üîç Running generateComparisonTable()...");


    const currentDomain = window.location.hostname;
    const filteredResults = priceResults.filter(result =>
        !currentDomain.includes(new URL(result.shopUrl).hostname)
    );

    // ‚úÖ **Define `noProductsFound` before using it**
    const noProductsFound = filteredResults.length === 0;

    if (noProductsFound) {
        return `
            <h4 style="display: inline; font-weight: 700;">Prissammenligning</h4>
            <p>Ingen andre butikker at sammenligne priser med.</p>
            ${productName ? 
                `<p><a href="https://www.google.com/search?q=${encodeURIComponent(productName)}" target="_blank" title="S√∏g efter ${(productName)} p√• Google">Pr√∏v en Google-s√∏gning üîç</a></p>` : 
                ''}
        `;
    }

    let tableRows = filteredResults.map(result => `
        <tr>
            <td style="padding: 5px;">${result.shop}</td>
            <td style="padding: 5px;">${result.eurPrice}</td>
            <td style="padding: 5px;">${result.dkkPrice}</td>
            <td style="padding: 5px;">
                ${result.price ? `<a href="${addUTMParameters(result.shopUrl)}"
                    class="track-click"
                    data-store="${result.shop}"
                    data-url="${result.shopUrl}"
                    data-name="${productName?.replace(/"/g, '&quot;')}"
                    data-price="${result.price}"
                    data-price-amount="${result.eurPrice || ''}"
                    data-price-currency="EUR"
                    data-gtin="${gtin || ''}"
                    data-mpn="${mpn || ''}"
                    data-referring-url="${window.location.href}"
                    target="_blank">Se produkt</a>` : "-"}
            </td>
        </tr>
    `).join("");

    return ` 
        <h4 style="display: inline; font-weight: 700;">Prissammenligning</h4>
        <p style="display: inline;">
            ${productName ? 
                `<a href="https://www.google.com/search?q=${encodeURIComponent(productName)}" target="_blank" title="S√∏g efter ${(productName)} p√• Google">üîç</a>` : 
                '-'
            }
        </p>
        <table cellpadding="5" style="border-collapse: separate; border-spacing: 5px;">
            <tr>
                <th style="padding: 5px; font-size: 10px;">Forhandler</th>
                <th style="padding: 5px; font-size: 10px;">Pris i EUR</th>
                <th style="padding: 5px; font-size: 10px;">Pris i DKK</th>
                <th style="padding: 5px; font-size: 10px;">Link</th>
            </tr>
            ${tableRows}
        </table>
        <div class="md:mr-12" style="margin-top: 10px; font-size: 8px !important; color: #666;">
            <p style="font-size: 10px;">Dette er kun en vejledning. Fast valutakurs p√• EUR: ${EUR_TO_DKK_RATE}.</p>
            <p style="font-size: 10px;">Priser kan variere grundet anden model og/eller moms.</p>
            <p style="font-size: 10px;"><strong>OBS:</strong> S√∏rg for at v√¶lge Denmark √∏verst p√• Bike Discount for at f√• den korrekte pris.</p>
        </div>
    `;
}



/* 
   function generateBikeDiscountRow() {
           const convertedPriceObj = convertPrice(bikeDiscountPrice || 'No match');
			const convertedPrice = convertedPriceObj.convertedPrice || 'No match';
	   return `
    <tr>
        <td style="padding: 5px;">Bike-Discount</td>
        <td style="padding: 5px;">${bikeDiscountPrice || 'No match'}</td>
        <td style="padding: 5px;">${convertedPrice}</td>
        <td style="padding: 5px;">${bikeDiscountPrice && !bikeDiscountPrice.includes('too') ? 
            `<a href="${addUTMParameters(bikeDiscountUrl)}" 
                class="track-click"
                data-store="Bike-Components"
                data-url="${bikeDiscountUrl}"
                data-name="${productName?.replace(/"/g, '&quot;')}"
                data-price="${bikeDiscountPrice}"
                target="_blank">View Product</a>` : '-'}</td>
    </tr>`;
}

function generateBikeComponentsRow() {
    const convertedPriceObj = convertPrice(bikeComponentsPrice || 'No match');
    const convertedPrice = convertedPriceObj.convertedPrice || 'No match';
    return `
    <tr>
        <td style="padding: 5px;">Bike-Components</td>
        <td style="padding: 5px;">${bikeComponentsPrice || 'No match'}</td>
        <td style="padding: 5px;">${convertedPrice}</td>
        <td style="padding: 5px;">${bikeComponentsPrice && !bikeComponentsPrice.includes('too') ? 
            `<a href="${addUTMParameters(bikeComponentsUrl)}" 
                class="track-click"
                data-store="Bike-Components"
                data-url="${bikeComponentsUrl}"
                data-name="${productName?.replace(/"/g, '&quot;')}"
                data-price="${bikeComponentsPrice}"
                target="_blank">View Product</a>` : '-'}</td>
    </tr>`;
}

function generateCykelgearRow() {
    const convertedPriceObj = convertPrice(cykelgearPrice || 'No match');
    const convertedPrice = convertedPriceObj.convertedPrice || 'No match';

    return `
    <tr>
        <td style="padding: 5px;">Cykelgear</td>
        <td style="padding: 5px;">${cykelgearPrice || 'No match'}</td>
        <td style="padding: 5px;">${convertedPrice}</td>
        <td style="padding: 5px;">${cykelgearPrice && !cykelgearPrice.includes('too') ? 
            `<a href="${addUTMParameters(cykelgearUrl)}" 
                class="track-click"
                data-store="Cykelgear"
                data-url="${cykelgearUrl}"
                data-name="${productName?.replace(/"/g, '&quot;')}"
                data-price="${cykelgearPrice}"
                target="_blank">View Product</a>` : '-'}</td>
    </tr>`;
} */



function insertPriceComparison(comparisonMessage, retryCount = 0) {
    const maxRetries = 5;
    const retryDelay = 1000;
    
    if (document.querySelector('.price-comparison-table')) {
        return;
    }

    const mpnElement = document.querySelector('[itemprop="mpn"]') || 
                       document.querySelector('[itemprop="sku"]') || 
                       document.querySelector('.product-id.site-text-xs') || 
                       document.querySelector('h1');
    
    if (!mpnElement && retryCount < maxRetries) {
        setTimeout(() => {
            insertPriceComparison(comparisonMessage, retryCount + 1);
        }, retryDelay);
        return;
    }

    const comparisonDiv = document.createElement('div');
    comparisonDiv.classList.add('price-comparison-table');
    comparisonDiv.innerHTML = comparisonMessage;
    comparisonDiv.style.marginTop = '10px';
    comparisonDiv.style.padding = '10px';
    comparisonDiv.style.border = '1px solid #ccc';

    if (mpnElement) {
        mpnElement.parentNode.insertBefore(comparisonDiv, mpnElement.nextSibling);
    } else {
        document.body.insertBefore(comparisonDiv, document.body.firstChild);
    }

    PriceTracker.attachTrackingHandlers();
}


function setupMutationObserver() {
    console.log('üîÑ Setting up mutation observer...');

    // Disconnect existing observer if any
    if (observer) {
        observer.disconnect();
        console.log('Existing observer disconnected');
    }

    // Find the most relevant container (modify based on site structure)
    const targetNode = document.querySelector('.product-details') || document.querySelector('.main-content') || document.body;

    if (!targetNode) {
        console.error('‚ùå Could not find a valid target node for MutationObserver.');
        return;
    }

    const config = {
        childList: true,
        subtree: true,
        attributes: true,
        characterData: true
    };

    observer = new MutationObserver((mutations) => {
        for (const mutation of mutations) {
            if (mutation.type === 'childList' || mutation.type === 'attributes') {
                console.log('üîÑ Product content changed:', mutation.target);
                processedGTINs.clear();
                findAndComparePrice();
                break;
            }
        }
    });

    observer.observe(targetNode, config);
    console.log(`‚úÖ Mutation observer started on: ${targetNode.className || targetNode.tagName}`);
}


// Call this on load and after navigation
document.addEventListener('DOMContentLoaded', setupMutationObserver);
window.addEventListener('load', setupMutationObserver);

// Also watch for URL changes
let lastUrl = location.href;
new MutationObserver(() => {
    const url = location.href;
    if (url !== lastUrl) {
        lastUrl = url;
        console.log('URL changed, setting up new observer');
        setupMutationObserver();
    }
}).observe(document.querySelector('body'), {subtree: true, childList: true});

// Call this in your initialization code
document.addEventListener('DOMContentLoaded', setupMutationObserver);
window.addEventListener('load', setupMutationObserver);

// Add this to your handleNavigation function

function handleNavigation() {
    console.log('üîÑ Navigation detected...');
    
    // Update URL and reset state
    currentUrl = window.location.href;
    processedGTINs.clear();
    
	

    // Setup product info object
    setupProductInfo();
    
    // Get current site information
    const { price: currentPrice, currency: currentCurrency } = getCurrentPriceAndCurrency();
    if (!currentPrice) {
        console.log('‚ùå No valid price found on current page');
        return;
    }

    // Convert prices for comparison
    const currentPriceEUR = currentCurrency === 'EUR' ? 
        currentPrice : 
        convertDkkToEur(currentPrice);
    
    console.log('üí∞ Current price:', {
        original: currentPrice,
        currency: currentCurrency,
        eurValue: currentPriceEUR
    });

    // Validate prices from different shops
    const shops = [
        {
            name: 'Bike-Discount',
            priceObj: bikeDiscountPriceObj,
            setPrice: (price) => { bikeDiscountPrice = price; },
            setPriceObj: (obj) => { bikeDiscountPriceObj = obj; }
        },
        {
            name: 'Bike-Components',
            priceObj: bikeComponentsPriceObj,
            setPrice: (price) => { bikeComponentsPrice = price; },
            setPriceObj: (obj) => { bikeComponentsPriceObj = obj; }
        }
    ];

    shops.forEach(shop => {
        if (typeof shop.priceObj !== 'undefined') {
            validateShopPrice(shop, currentPrice, currentPriceEUR);
        }
    });

    // Update the UI
    findAndComparePrice();
    
    // Setup observers for future changes
    setupMutationObserver();
}

function validateShopPrice(shop, currentPrice, currentPriceEUR) {
    if (!shop.priceObj || isNaN(shop.priceObj.eurValue)) {
        console.log(`‚ùå Invalid price for ${shop.name}, skipping validation.`);
        return;
    }

    const isValid = validatePrice(currentPrice, shop.priceObj.eurValue, shop.priceObj.currency);

    if (!isValid) {
        console.log(`‚ùå Price on ${shop.name} rejected due to extreme deviation.`);
        shop.setPrice(null); // Store `null` instead of `"No match"`
        shop.setPriceObj(null);
    } else {
        console.log(`‚úÖ Price on ${shop.name} is valid.`);
    }
}


function getValidationMessage(shopPrice, currentPrice) {
    const threshold = 1.8;
    if (shopPrice > (currentPrice * threshold)) {
        return "mismatch‚Üë (too high)";
    }
    if (shopPrice < (currentPrice / threshold)) {
        return "mismatch‚Üì (too low)";
    }
    return "mismatch";
}

function reattachListeners() {
    console.log('üîÑ Reattaching navigation listeners...');
    window.addEventListener('popstate', handleNavigation);
    window.addEventListener('pushstate', handleNavigation);
    window.addEventListener('replacestate', handleNavigation);
}

function handleNavigation() {
    console.log('üîÑ Navigation detected:', location.href);
    
    setTimeout(() => {
        console.log('üîç Running product detection...');
        processedGTINs.clear();
        findAndComparePrice();
        reattachListeners(); // Ensure listeners persist
    }, 500);
}

// Ensure listeners are always active
reattachListeners();


// Initialize and set up all event listeners
handleNavigation();

/* // Listen for URL changes
let lastUrl = location.href;
new MutationObserver(() => {
    const url = location.href;
    if (url !== lastUrl) {
        lastUrl = url;
        handleNavigation();
    }
}).observe(document.querySelector('body'), {subtree: true, childList: true}); */

// Standard navigation events
window.addEventListener('pushstate', handleNavigation);
window.addEventListener('replacestate', handleNavigation);
window.addEventListener('popstate', handleNavigation);

// Additional events that might indicate page changes
window.addEventListener('load', handleNavigation);
document.addEventListener('DOMContentLoaded', handleNavigation);

// Add URL change detection through History API override
const pushState = history.pushState;
history.pushState = function() {
    pushState.apply(history, arguments);
    handleNavigation();
};

const replaceState = history.replaceState;
history.replaceState = function() {
    replaceState.apply(history, arguments);
    handleNavigation();
};

function extractPrice(element) {
    if (!element) return null;

    // Get text content and clean it
    let priceText = element.textContent.trim();
    
    // Remove any currency symbols and normalize decimal separator
    priceText = priceText.replace(/[¬£$‚Ç¨]/g, '')  // Remove currency symbols
                         .replace(/,/g, '.')       // Normalize decimal separator
                         .replace(/[^\d.]/g, '')   // Remove any non-digit characters except decimal point
                         .trim();

    // Convert to number
    const price = parseFloat(priceText);

    // Validate the price
    if (isNaN(price) || price <= 0 || price > 100000) { // Assuming no bike part costs more than 100,000
        console.log('Invalid price found:', priceText);
        return null;
    }

    return price;
}

function processSearchResults(searchResults) {
    let noProductsFound = true;  // Define the variable at the start of the function
    
    if (!searchResults || searchResults.length === 0) {
        console.log('No search results found');
        return;
    }

    searchResults.forEach(result => {
        if (result.price) {
            noProductsFound = false;  // Set to false if we find any products
            const currentPrice = extractPrice(result.priceElement);
            const comparisonPrice = result.price;

            if (!validatePrice(currentPrice, comparisonPrice)) {
                console.log('Price validation failed - skipping comparison');
                return;
            }
            // Continue processing the valid result...
        }
    });

    if (noProductsFound) {
        console.log('No valid products found after price validation');
    }
}
